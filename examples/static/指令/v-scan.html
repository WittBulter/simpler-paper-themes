<h2 id="-">曝光埋点触发指令</h2>
<h3 id="-">初衷</h3>
<p>首先我们已经有太多的曝光计算方式, 但它们都并不适合目前 <code>h5</code> 项目的实际曝光需求, 如基于 <code>ubt-web</code> 的 <code>visit</code> 指令是通过定时器不断遍历子元素计算 <code>ClientRect</code> 来触发曝光, 这类传统的计算方式暴露了很多缺陷：</p>
<ol>
<li>触发缓慢同时会严重影响性能 </li>
<li>定时器没有很好的得到释放, 大型列表可能会发生内存泄露</li>
<li><code>ClientRect</code> 会导致浏览器 <code>reflow</code>, 请参见<a href="gist.github.com/paulirish/5d52fb081b3570c81e3a">这里</a>  </li>
<li>细节粗暴, 不适合追求性能的页面。如在选取列表时不断刷<a href="https://github.com/eleme/ubt-web/blob/master/lib/events/visit.js#L35">全局 DOM 操作</a></li>
<li>设计模式很难契合如今的多参数曝光方式</li>
</ol>
<p>常见的曝光埋点方式 <code>getBoundingClientRect</code> 会导致浏览器 reflow 列表较多时性能低下, 参见
为了解决这些问题, 我们设计了 <code>v-scan</code> 指令, 它能够被轻易的移植到任何,环境下, 同时选取的粒度较大, 也为不同业务保留珍贵的扩展能力。  </p>
<p>当然, 最重要的是, <code>v-scan</code> 能够轻易的计算数以万计的列表项, ,同时 100% 确保 UI 渲染不会受到任何影响, 实际上, 即便是业务逻辑也不会因此遭遇阻塞。想要了解更多异步与安全计算模式, 请参考 <code>requestIdleCallback</code> 。</p>
<h3 id="-">考量</h3>
<p>当然这看起来这可以作为 <code>ubt-web</code> 的一次无痛升级, 但在我们考虑到更多情况时放弃这样做：</p>
<ul>
<li><p><code>ubt-web</code> 服务于非常多的页面, 升级缓慢同时需要大量测试兼容性  </p>
</li>
<li><p>创建新的 API 会使本就臃肿的 <code>ubt-web</code> ,雪上加霜, 这是我们不愿意见到的, 特别是 <code>ubt-web</code> 还会在 template 中直接渲染, 并非每个页面都需要高性能的曝光计算方式, 特别是为了兼容性引入 <code>polyfill</code> 后。它带来的负担不应让每一个项目去承担。</p>
</li>
<li><code>ubt-web</code> 的代码稍显粗暴且有些过时(可能是对业务与需求做出的妥协), 无论如何, 可以肯定的是它本身没有经过优良的设计(如考虑未来 key / 参数 / handle的变化, ,可读性与 DOM 操作性能问题等等), 如果今天偶然发现, <code>ubt-web</code> ,无法再满足我们的需求, 要做的不是,为它打补丁(这样做会使它越来越老旧, 甚至难以维护, 成为整体项目的拖油瓶), 而是做出更好更富有现代性更深思熟虑的组件来舒解它的压力。</li>
<li>,太多的组件容易分散开发者注意力, ,同时,多数人都喜欢用自己的组件、库, 会对生产力有所影响, 也是, <code>vue-plugins</code> 的,痛点之一。  </li>
</ul>
<h3 id="-">使用</h3>
<p><code>v-scan</code> 只有近似简陋的 API, ,它可以被标注在任何元素中, 同时不受 <code>document scroll</code> 或 <code>element scroll</code> 的影响。</p>
<p>你也可以利用它来做一些有趣的事: </p>
<ol>
<li>将 ,<code>v-scan</code> 标注在 LoadMore 的元素块中, 可以以极高的性能获得加载,事件。</li>
<li>,在图片或图标上标识, 便于延迟加载。</li>
</ol>
<pre><code class="lang-js">import { ScanObserver } from &#39;howl-theme&#39;


// threshold number[] optional 指定触发机制 (元素可见多少时触发) enums: [0, 0.25, 0.5, 0.75, 1]
Vue.use(ScanObserver, { threshold })


// v-scan elementAttr required ,值为触发后的回调函数
// scanData elementAttr optional 值会被传入回调函数
&lt;Item v-scan=&quot;sendUBTEventHandle&quot; :scanData={ id: index }&gt;


// ...
sendUBTEventHandle(event, data) { // something }
</code></pre>
